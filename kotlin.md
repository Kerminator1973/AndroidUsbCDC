# Особенности Kotlin

Это моё первое приложение на **Kotlin** и кажется разумным зафиксировать отличия в синтаксисе языка от кода на Java.

Выведение типа работает очень эффективно и единственное, что нужно указать - будет ли определяемый объект изменяться (var), или останется неизменным (val).

Строка кода не должна завершаться точкой с запятой.

Работает механизм String Interpolation, который "под капотом" задействует **StringBuffer**. Надёжно, понятно, не особенно быстро:

``` kotlin
val message = "pid = ${driver.device.productId}, vid =  ${driver.device.vendorId}, Name = ${driver.device.deviceName}"
```

Преобразование типов выполняется с помощью оператора as: `manager as UsbManager?`, а знак вопроса в конце типа означает, что тип является **nullable**.

Особенность разработки под Android - добавление, практически, любого типа требует использования директивы **import**.

## Функции области видимости

Встроенный в Android Studio механизм рефакторинга кода предлагает использовать ключевое слово **also**, например:

``` kt
"No driver available".also { message.text = it }
```

Ключевое слово also относится к пяти функциям области видимости. Целью этих функций является выполнение блока кода в контексте объекта. Эти функции формируют временную область видимости для объекта, к которому были применены, и вызывают код, указанный в переданном лямбда-выражении. В этой области видимости можно получить доступ к объекту без явного к нему обращения по имени.

Всего их пять: let, run, with, apply, и also. Все эти функции делают одно и то же: выполняют блок кода для объекта. Отличие состоит в том, как этот объект становится доступным внутри блока и каков результат всего выражения.

Например, мы могли бы явным образом создать переменную alice и использовать её:

``` kt
fun main() {
    val alice = Person("Alice", 20, "Amsterdam")
    println(alice)
    alice.moveTo("London")
    alice.incrementAge()
    println(alice)
}
```

Однако, мы могли бы и не создавать переменную явным образом, а выполнить её во внутреннем контексте. Обращаться к экземпляру созданного экземпляра класса Person можно было бы через it:

``` kt
fun main() {
    Person("Alice", 20, "Amsterdam").let {
        println(it)
        it.moveTo("London")
        it.incrementAge()
        println(it)
    }
}
```

Цель модификации кода - сократить количество переменных в области видимости.

Почитать больше: https://kotlinlang.ru/docs/scope-functions.html

## Android Studio

IDE Android Studio распознаёт код на Java, находящийся в буфере обмена и при выполнении вставки предлагает преобразовать его в код на Kotlin.

В IDE можно выполнить конвертацию Java-файла в Kotlin-файл, используя команду в меню Android Studio: **Code | Convert Java File to Kotlin File**.
